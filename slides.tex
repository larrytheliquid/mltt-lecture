\documentclass[mathserif]{beamer}
\usetheme{Warsaw}
\usepackage{mathpartir}

\title{Martin-L{\"o}f's Type Theory (MLTT)}
\author{Larry Diehl}
\institute{University of Iowa - Guest Lecture}
\date[April 26, 2018]
{CS:5860 Lambda Calculus and Applications}

\newcommand{\istype}[1]{\ensuremath{#1 ~\textbf{\textrm{type}}}}
\newcommand{\isterm}[2]{\ensuremath{#1 ~\textbf{{:}}~ #2}}

\newcommand{\eqtype}[2]{\ensuremath{#1 ~\textbf{=}~ #2}}
\newcommand{\eqterm}[3]{\ensuremath{#1 ~\textbf{=}~ #2 ~\textbf{{:}}~ #3}}

\newcommand{\hyp}[1]{\ensuremath{~[\isterm{x}{#1}]}}

\newcommand{\Funv}[3]{\ensuremath{\Pi #1{:}#2. #3}}
\newcommand{\Fun}[2]{\Funv{x}{#1}{#2}}
\newcommand{\funv}[2]{\ensuremath{\lambda #1. #2}}
\newcommand{\fun}[1]{\funv{x}{#1}}
\newcommand{\app}[2]{\ensuremath{#1~#2}}
\newcommand{\sub}[2]{\ensuremath{#1[#2/x]}}


\begin{document}
\frame{\titlepage}

\begin{frame}
\frametitle{Curry-Howard Isomorphism}

\textbf{Propositions as types and proofs as terms}.
Use $\lambda$-calculus as a proof language.
Verified programming by encoding specifications
into types (as logical propositions), and
writing programs that only type-check if they
satisfy the specifications.

MLTT allows any proposition (of intuitionistic logic)
to be represented by a type.

\end{frame}


\begin{frame}
\frametitle{Curry-Howard Isomorphism}
\framesubtitle{System F}

\end{frame}

\begin{frame}
\frametitle{Curry-Howard Isomorphism}
\framesubtitle{MLTT}

\end{frame}

\begin{frame}
\frametitle{Verified Programming}

\end{frame}


\begin{frame}
\frametitle{Large Eliminations}

\end{frame}

\begin{frame}
\frametitle{MLTT Syntax}

Unified syntax for types and terms,
so typehood and termhood are determined \textit{judgementally}.

\begin{block}{Grammar}
$A,B,a,b,f ::= ...~|~\Fun{A}{B}~|~\fun{b}~|~\app{f}{a}~|~...$
\end{block}

\end{frame}


\begin{frame}
\frametitle{MLTT Judgements}

Static and dynamic semantics are mutually defined judgements.

\begin{block}{Type is well-formed}
\istype{A}
\end{block}

\begin{block}{Term has type}
\isterm{a}{A}
\end{block}

\begin{block}{Type is equal to type}
\eqtype{A}{B}
\end{block}

\begin{block}{Term is equal to term at type}
\eqterm{a}{a'}{A}
\end{block}


\end{frame}

\begin{frame}
\frametitle{Hypothetical Judgements}
\framesubtitle{or, ``higher-order'' judgements}

\begin{block}{Explicit context}
$\Gamma \vdash \istype{A}$
\end{block}

\begin{block}{Implicit (meta-level) context}
\istype{A}
\end{block}

\end{frame}

\begin{frame}
\frametitle{Hypothetical Judgements}
\framesubtitle{or, ``higher-order'' judgements}

\begin{block}{Explicit context}
$\Gamma, x{:}A \vdash \istype{B}$
\end{block}

\begin{block}{Implicit (meta-level) context}
\istype{B} \hyp{A}
\end{block}

\end{frame}

\begin{frame}
\frametitle{Computation in Types}

%% lam A. lam a. a : (A : U) -> A -> (lam X. X) A

\end{frame}

\begin{frame}
\frametitle{Equality and Conversion Rules}

\end{frame}


\begin{frame}
\frametitle{Package of Rules per Type}
\framesubtitle{e.g. the type of dependent functions}

\begin{block}{Type formation}
e.g. \Fun{A}{B}, and congruences.
\end{block}

\begin{block}{Term introduction}
e.g. \fun{b}, and congruences.
\end{block}

\begin{block}{Term elimination}
e.g. \app{f}{a}, and congruences.
\end{block}

\begin{block}{Equality}
  e.g. $\app{(\fun{b})}{a} =_\beta \sub{b}{a}$, and
  $f =_\eta \fun{\app{f}{x}}$.
\end{block}

\end{frame}


\begin{frame}
\frametitle{Dependent Functions ($\Pi$ types)}

$$
\inferrule{
  {\istype{A}}
  \\
  {\istype{B} \hyp{A}}
}
{\istype{\Fun{A}{B}}}
$$

$$
\inferrule{
  {\isterm{b}{B} \hyp{A}}
}
{\isterm{\fun{b}}{\Fun{A}{B}}}
\qquad
\inferrule{
  {\isterm{\fun{b}}{\Fun{A}{B}}}
  \\
  {\isterm{a}{A}}
}
{\isterm{\app{f}{a}}{\sub{B}{a}}}
$$

$$
\inferrule{
  {\isterm{a}{A}}
  \\
  {\isterm{b}{B} \hyp{A}}
}
{\eqterm{\app{(\fun{b})}{a}}{\sub{b}{a}}{\sub{B}{a}}}
\qquad
\inferrule{
  {\isterm{f}{\Fun{A}{B}}}
}
{\eqterm{f}{\fun{\app{f}{x}}}{\Fun{A}{B}}}
$$

\end{frame}

\begin{frame}
\frametitle{Dependent Functions ($\Pi$ types)}
\framesubtitle{Congruence Rules}

$$
\inferrule{
  {\eqtype{A}{A'}}
  \\
  {\eqtype{B}{B'} \hyp{A}}
}
{\eqtype{\Fun{A}{B}}{\Fun{A'}{B'}}}
$$

$$
\inferrule{
  {\eqterm{b}{b'}{B} \hyp{A}}
}
{\eqterm{\fun{b}}{\fun{b'}}{\Fun{A}{B}}}
\qquad
\inferrule{
  {\eqterm{f}{f'}{\Fun{A}{B}}}
  \\
  {\eqterm{a}{a'}{A}}
}
{\eqterm{\app{f}{a}}{\app{f'}{a'}}{\sub{B}{a}}}
$$

\end{frame}


\begin{frame}
\frametitle{Church-Encoded Datatypes}
\framesubtitle{System F}

\end{frame}

\begin{frame}
\frametitle{W-Encoded Datatypes}
\framesubtitle{MLTT}

\end{frame}


\begin{frame}
\frametitle{Metatheoretic Properties}

\end{frame}


\end{document}

