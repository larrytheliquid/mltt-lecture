\documentclass[mathserif]{beamer}
\usetheme{Warsaw}
\usepackage{mathpartir}
\usepackage{cancel}

\title{Martin-L{\"o}f's Type Theory (MLTT)}
\author{Larry Diehl}
\institute{University of Iowa - Guest Lecture}
\date[April 26, 2018]
{CS:5860 Lambda Calculus and Applications}

\newcommand{\bad}[1]{\textcolor{red}{\cancel{#1}}}

\newcommand{\txt}[1]{\textrm{#1}}
\newcommand{\defeq}[0]{\ensuremath{\triangleq}}
%% \newcommand{\defeq}[2]{\ensuremath{#1 ~\triangleq~ #2}}

\newcommand{\istype}[1]{\ensuremath{#1 ~\textbf{\textrm{type}}}}
\newcommand{\isterm}[2]{\ensuremath{#1 ~\textbf{{:}}~ #2}}

\newcommand{\eqtype}[2]{\ensuremath{#1 ~\textbf{=}~ #2}}
\newcommand{\eqterm}[3]{\ensuremath{#1 ~\textbf{=}~ #2 ~\textbf{{:}}~ #3}}

\newcommand{\hyp}[1]{\ensuremath{~[\isterm{x}{#1}]}}

\newcommand{\Arr}[2]{\ensuremath{#1 \rightarrow #2}}

\newcommand{\Funv}[3]{\ensuremath{\Pi #1{:}#2. #3}}
\newcommand{\Fun}[2]{\Funv{x}{#1}{#2}}
\newcommand{\funv}[2]{\ensuremath{\lambda #1. #2}}
\newcommand{\fun}[1]{\funv{x}{#1}}
\newcommand{\app}[2]{\ensuremath{#1~#2}}
\newcommand{\sub}[2]{\ensuremath{#1[#2/x]}}

\newcommand{\Pairv}[3]{\ensuremath{\Sigma #1{:}#2. #3}}
\newcommand{\Pair}[2]{\Pairv{x}{#1}{#2}}
\newcommand{\pair}[2]{\ensuremath{\(#1, #2\)}}
\newcommand{\fst}[1]{\ensuremath{\pi_1~#1}}
\newcommand{\snd}[1]{\ensuremath{\pi_2~#1}}

\newcommand{\Type}[0]{\ensuremath{\mathcal{U}}}

\newcommand{\Unit}[0]{\ensuremath{\top}}
\newcommand{\unit}[0]{\ensuremath{\txt{tt}}}
\newcommand{\Bot}[0]{\ensuremath{\bot}}
\newcommand{\elimBot}[1]{\ensuremath{\texttt{elim}_{\Bot}~#1}}

\newcommand{\Bool}[0]{\ensuremath{\mathbb{B}}}
\newcommand{\true}[0]{\ensuremath{\txt{tt}}}
\newcommand{\false}[0]{\ensuremath{\txt{ff}}}
\newcommand{\elimBool}[3]{\ensuremath{\texttt{elim}_{\Bool}~#1~#2~#3}}

\begin{document}
\frame{\titlepage}

\begin{frame}
\frametitle{Curry-Howard Isomorphism}

\textbf{Propositions as types and proofs as terms}.
Use $\lambda$-calculus as a proof language.
Verified programming by encoding specifications
into types (as logical propositions), and
writing programs that only type-check if they
satisfy the specifications.

MLTT allows any proposition (of intuitionistic logic)
to be represented by a type.
Hence, \textbf{MLTT is a single language
suitable for both programming and theorem proving}.

\end{frame}

\begin{frame}
\frametitle{Curry-Howard Isomorphism}
\framesubtitle{System F}

\end{frame}

\begin{frame}
\frametitle{Curry-Howard Isomorphism}
\framesubtitle{MLTT}

\end{frame}

\begin{frame}
\frametitle{Verified Programming}

\begin{block}{Dependently Typed Programming Languages}
Modern dependently typed programming languages, or proof assistants,
implement variations of MLTT (e.g. Agda, Coq, Idris, Lean, etc.).
\end{block}

\end{frame}

\begin{frame}
\frametitle{MLTT Syntax}

Unified syntax for types and terms,
so typehood and termhood are determined \textit{judgementally}.

\begin{block}{Grammar}
$A,B,a,b,f ::= ...~|~\Fun{A}{B}~|~\fun{b}~|~\app{f}{a}~|~...$
\end{block}

\end{frame}


\begin{frame}
\frametitle{MLTT Judgements}

Static and dynamic semantics are mutually defined judgements.

\begin{block}{Type is well-formed}
\istype{A}
\end{block}

\begin{block}{Term has type}
\isterm{a}{A}
\end{block}

\begin{block}{Type is equal to type}
\eqtype{A}{B}
\end{block}

\begin{block}{Term is equal to term at type}
\eqterm{a}{a'}{A}
\end{block}


\end{frame}

\begin{frame}
\frametitle{Hypothetical Judgements}
\framesubtitle{or, ``higher-order'' judgements}

\begin{block}{Explicit context}
$\Gamma \vdash \istype{A}$
\end{block}

\begin{block}{Implicit (meta-level) context}
\istype{A}
\end{block}

\end{frame}

\begin{frame}
\frametitle{Hypothetical Judgements}
\framesubtitle{or, ``higher-order'' judgements}

\begin{block}{Explicit context}
$\Gamma, x{:}A \vdash \istype{B}$
\end{block}

\begin{block}{Implicit (meta-level) context}
\istype{B} \hyp{A}
\end{block}

\end{frame}

\begin{frame}
\frametitle{Equality is an Equivalence Relation}

$$
\inferrule{
  {\istype{A}}
}
{\eqtype{A}{A}}
\qquad
\inferrule{
  {\isterm{a}{A}}
}
{\eqterm{a}{a}{A}}
$$

$$
\inferrule{
  {\eqtype{A}{A'}}
}
{\eqtype{A'}{A}}
\qquad
\inferrule{
  {\eqterm{a}{a'}{A}}
}
{\eqterm{a'}{a}{A}}
$$

$$
\inferrule{
  {\eqtype{A_1}{A_2}}
  \\
  {\eqtype{A_2}{A_3}}
}
{\eqtype{A_1}{A_3}}
\qquad
\inferrule{
  {\eqterm{a_1}{a_2}{A}}
  \\
  {\eqterm{a_2}{a_3}{A}}
}
{\eqterm{a_1}{a_3}{A}}
$$

\end{frame}

\begin{frame}
\frametitle{Package of Rules per Type}
\framesubtitle{e.g. the type of dependent functions}

\begin{block}{Type formation}
e.g. \Fun{A}{B}, congruences, and \textit{universe encoding}.
\end{block}

\begin{block}{Universe introduction}
e.g. \Fun{A}{B}, {\`a} la Russell.
\end{block}

\begin{block}{Term introduction}
e.g. \fun{b}, and congruences.
\end{block}

\begin{block}{Term elimination}
e.g. \app{f}{a}, and congruences.
\end{block}

\begin{block}{Equality}
  e.g. $\app{(\fun{b})}{a} =_\beta \sub{b}{a}$, and
  $f =_\eta \fun{\app{f}{x}}$.
\end{block}

\end{frame}

\begin{frame}
\frametitle{A Universe (\Type) of Types}

\begin{itemize}

\item
The universe type \Type ~is a safe version of a ``type of types'',
where each type is represented as a \textit{code}
(which is a term) of type \Type.

\item
Each code for a type can be \textit{lifted} to a proper type,
meaning it satisfies the type formation judgement (\istype{A}).

\item
\Type ~is a \textit{predicative} reflection of well-formed types
as terms (typeable by \Type).

\item
Quantifying over universe \textit{codes} (\Type) corresponds to
\textit{predicatively} quantifying over \textit{types}. 

\item
Hence, each \textit{type formation rule} is mirrored
by a \textit{universe introduction rule}.\footnote{
  Except for the \Type-formation rule.
  }

\end{itemize}

\end{frame}

\begin{frame}
\frametitle{Universe ($\Type$ type)}
\framesubtitle{Formation Rules}

$$
\inferrule{
  {}
}
{\istype{\Type}}
\qquad
\inferrule{
  {\isterm{A}{\Type}}
}
{\istype{A}}
$$

$$
\bad{\inferrule{
  {}
}
{\isterm{\Type}{\Type}}}
$$

\end{frame}

\begin{frame}
\frametitle{Predicative Universe}
\framesubtitle{e.g. the identity function type}

$$
\istype{\Funv{A}{\Type}{\Arr{A}{A}}}
$$

$$
\bad{\isterm{\Funv{A}{\Type}{\Arr{A}{A}}}{\Type}}
$$

\end{frame}

\begin{frame}
\frametitle{Dependent Functions ($\Pi$ types)}

$$
\inferrule{
  {\istype{A}}
  \\
  {\istype{B} \hyp{A}}
}
{\istype{\Fun{A}{B}}}
\qquad
\inferrule{
  {\isterm{A}{\Type}}
  \\
  {\isterm{B}{\Type} \hyp{A}}
}
{\isterm{\Fun{A}{B}}{\Type}}
$$

$$
\inferrule{
  {\isterm{b}{B} \hyp{A}}
}
{\isterm{\fun{b}}{\Fun{A}{B}}}
\qquad
\inferrule{
  {\isterm{\fun{b}}{\Fun{A}{B}}}
  \\
  {\isterm{a}{A}}
}
{\isterm{\app{f}{a}}{\sub{B}{a}}}
$$

$$
\inferrule{
  {\isterm{a}{A}}
  \\
  {\isterm{b}{B} \hyp{A}}
}
{\eqterm{\app{(\fun{b})}{a}}{\sub{b}{a}}{\sub{B}{a}}}
\qquad
\inferrule{
  {\isterm{f}{\Fun{A}{B}}}
}
{\eqterm{f}{\fun{\app{f}{x}}}{\Fun{A}{B}}}
$$

\end{frame}

\begin{frame}
\frametitle{Dependent Functions ($\Pi$ types)}
\framesubtitle{Congruence Rules (suppressed henceforth)}

$$
\inferrule{
  {\eqtype{A}{A'}}
  \\
  {\eqtype{B}{B'} \hyp{A}}
}
{\eqtype{\Fun{A}{B}}{\Fun{A'}{B'}}}
\qquad
\inferrule{
  {\eqterm{A}{A'}{\Type}}
  \\
  {\eqterm{B}{B'}{\Type} \hyp{A}}
}
{\eqterm{\Fun{A}{B}}{\Fun{A'}{B'}}{\Type}}
$$

$$
\inferrule{
  {\eqterm{b}{b'}{B} \hyp{A}}
}
{\eqterm{\fun{b}}{\fun{b'}}{\Fun{A}{B}}}
\qquad
\inferrule{
  {\eqterm{f}{f'}{\Fun{A}{B}}}
  \\
  {\eqterm{a}{a'}{A}}
}
{\eqterm{\app{f}{a}}{\app{f'}{a'}}{\sub{B}{a}}}
$$

\end{frame}

\begin{frame}
\frametitle{Computation in Types}

\begin{align*}
\txt{Id} &\defeq \funv{A}{A} \\
\txt{id} &\defeq \funv{A}{\funv{a}{a}}
\end{align*}

$$
\isterm{\txt{Id}}{\Arr{\Type}{\Type}}
\qquad
\isterm{\txt{id}}{\Funv{A}{\Type}{\Arr{A}{\app{\txt{Id}}{A}}}}
$$

\end{frame}

\begin{frame}
\frametitle{Conversion Rules}
\framesubtitle{Equality of Types}

$$
\inferrule{
  {\isterm{a}{A}}
  \\
  {\eqtype{A}{A'}}
}
{\isterm{a}{A'}}
\qquad
\inferrule{
  {\eqterm{a}{a'}{A}}
  \\
  {\eqtype{A}{A'}}
}
{\eqterm{a}{a'}{A'}}
$$

\end{frame}

\begin{frame}
\frametitle{Computation in Types}
\framesubtitle{Example derivation}

\end{frame}

\begin{frame}
\frametitle{MLTT Open to Extension}

\begin{block}{Core}
Can consider $\Pi$ and \Type~ the ``core'' types of MLTT.
\end{block}

\begin{block}{Open to Extension}
Per Martin-L{\"o}f preferred his theory to be ``open to extension'',
in the sense that adding new types
(like lists, vectors, an internalized equality type, etc.) should
remain possible.\footnote{
  This is why there is no elimination rule for \Type.
} Even axioms (that keep the theory consistent) may be added,
like excluded middle, but at the cost of ``stuck'' computations.
\end{block}

\begin{block}{Minimal Theory for Inductive Types}
Next, we will extend MLTT with a minimal collection of types
that allows inductive types (e.g. $\mathbb{N}$) to be \textit{derived}:
\\\Bot, \Unit, $\Sigma$, \Bool, and $\mathcal{W}$.
\end{block}



\end{frame}

\begin{frame}
\frametitle{Unit ($\Unit$ type)}

$$
\inferrule{
  {}
}
{\istype{\Unit}}
\qquad
\inferrule{
  {}
}
{\isterm{\Unit}{\Type}}
$$

$$
\inferrule{
  {}
}
{\isterm{\unit}{\Unit}}
\qquad
\inferrule{
  {\isterm{u}{\Unit}}
}
{\eqterm{u}{\unit}{\Unit}}
$$

\end{frame}

\begin{frame}
\frametitle{Dependent Pairs ($\Sigma$ types)}

$$
\inferrule{
  {\istype{A}}
  \\
  {\istype{B} \hyp{A}}
}
{\istype{\Pair{A}{B}}}
\qquad
\inferrule{
  {\isterm{A}{\Type}}
  \\
  {\isterm{B}{\Type} \hyp{A}}
}
{\isterm{\Pair{A}{B}}{\Type}}
$$

$$
\inferrule{
  {\istype{A}}
  \\
  {\istype{B} \hyp{A}}
}
{\istype{\Pair{A}{B}}}
$$

\end{frame}

\begin{frame}
\frametitle{Bottom ($\Bot$ type)}

$$
\inferrule{
  {}
}
{\istype{\Bot}}
\qquad
\inferrule{
  {}
}
{\isterm{\Bot}{\Type}}
$$

$$
\inferrule{
  {\istype{A}}
  \\
  {\isterm{e}{\Bot}}
}
{\isterm{\elimBot{e}}{A}}
$$

\end{frame}

\begin{frame}
\frametitle{Booleans ($\Bool$ type)}

$$
\inferrule{{}}
{\istype{\Bool}}
\qquad
\inferrule{{}}
{\isterm{\Bool}{\Type}}
\qquad
\inferrule{{}}
{\isterm{\true}{\Bool}}
\qquad
\inferrule{{}}
{\isterm{\false}{\Bool}}
$$

$$
\inferrule{
  {\istype{P} \hyp{\Bool}}
  \\
  {\isterm{p_t}{\sub{P}{\true}}}
  \\  
  {\isterm{p_f}{\sub{P}{\false}}}
  \\
  {\isterm{b}{\Bool}}
}
{\isterm{\elimBool{p_t}{p_f}{b}}{\sub{P}{b}}}
$$

$$
\inferrule{
  {\istype{P} \hyp{\Bool}}
  \\
  {\isterm{p_t}{\sub{P}{\true}}}
  \\  
  {\isterm{p_f}{\sub{P}{\false}}}
}
{\eqterm{\elimBool{p_t}{p_f}{\true}}{p_t}{\sub{P}{\true}}}
$$

$$
\inferrule{
  {\istype{P} \hyp{\Bool}}
  \\
  {\isterm{p_t}{\sub{P}{\true}}}
  \\  
  {\isterm{p_f}{\sub{P}{\false}}}
}
{\eqterm{\elimBool{p_t}{p_f}{\false}}{p_f}{\sub{P}{\false}}}
$$

\end{frame}

\begin{frame}
\frametitle{Large Eliminations}

\begin{block}{Large Elimination}
A function that computes a type from a term.
\end{block}

\begin{block}{Predicates}
Can be represented as a function (i.e. a large elimination)
from booleans (\Bool) to types. If the predicate is satisfied, the
function returns \Unit (which is inhabited),
otherwise it returns \Bot (which is uninhabited). Predicates can similarly
be defined over other types
(e.g. an \txt{IsSorted} predicate from lists to types).
\end{block}

\begin{block}{Families of Types}
Also called \textit{indexed types}. These are the same as predicates,
but contain additional data of computational value, beyond mere
inhabitance (e.g. a vector of elements indexed by the natural numbers). 
\end{block}

\end{frame}



\begin{frame}
\frametitle{Church-Encoded Datatypes}
\framesubtitle{System F}

\end{frame}

\begin{frame}
\frametitle{W-Encoded Datatypes}
\framesubtitle{MLTT}

\end{frame}

\begin{frame}
\frametitle{Intuitionistic Logic}

%% separate slides for pairs, disjoint unions, etc
%% maybe show constructors for disjunction
%% define implication, conjunction, and disjunction as type synonyms
%% also Curry-Howard table of other logical types
%% negation

\end{frame}

\begin{frame}
\frametitle{Metatheoretic Properties}

\end{frame}

\begin{frame}
\frametitle{References}

1984 book, retypeset version,
and github papers repo.

\end{frame}


\end{document}

